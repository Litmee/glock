package treaty

import (
	"bufio"
)

// Decode message decoding
func Decode(r *bufio.Reader) ([]byte, error) {

	_, err := r.Peek(1)
	if err != nil {
		return nil, err
	}
	// Identification parameters used to solve TCP subcontract problems
	var sign byte = 0

	// Container for fetching byte streams
	// Origin of s slice size
	// Message Body Frame Definition:
	// The first byte is the id of the business that needs to be locked
	// The second byte is the identification bit: 0 means the request is to acquire the lock, 1 means the request is to release the lock
	// The third to fourth bytes are the unsigned random numbers generated by the client at startup
	// The last eight bytes are the id of the client request to initiate the goroutine, which is used for the implementation of the reentrant lock
	s := make([]byte, 12)

	// Return the current number of readable bytes in the buffer through the Buffered method
	// Less than 5 to be processed
	if r.Buffered() < 12 {
		// return nil, err
		sign = byte(r.Buffered())
		s = make([]byte, sign)
	}

	// read message entity
	_, err = r.Read(s)
	if err != nil {
		return nil, err
	}

	// sign != 0 indicates that there is subcontracting and needs to be spliced
	if sign != 0 {
		_, _ = r.Peek(1)
		newS := make([]byte, 12-sign)
		_, err = r.Read(newS)
		if err != nil {
			return nil, err
		}
		s = append(s, newS...)
	}

	// Return
	return s, nil
}
